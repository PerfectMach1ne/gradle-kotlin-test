/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package gradle.kotlin.test

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

fun main() { // I love to death that functions in Kotlin are all defined by just "fun". fun!! FUN!!!!!!!!
    println(App().greeting)
    // val - value, cannot be changed
    // var - variable, can be changed
    var message: String = """
        Heloooo
        woooorld
    """.trimIndent() // Removes the indent and newline taken from the code
    // Alternatively, use .replaceIndent("#")
    println(message)
    message = """
        Heloooo
        woooorld
    """.replaceIndent("#.")
    println(message)
    /* .trimIndent() can also be replaced with something like .trimMargin(),
        but then we'll have to pass a string of specific characters in the method and
        then write them at the start of each new line, like below. Default char is '|'
    */
    message = """
        >>>Heloooo
        >>>woooorld
    """.trimMargin(">>>")
    println(message)
    val bruh = "123"
    print("helo world: ${App().greeting} and \"123\": $bruh which is ${bruh.length} characters long\n")
//    var isBlank: Boolean = false  this gives a warning that "Boolean" is reduntant and stops a push just to tell it.
    var isBlank = false
    println(isBlank.not())
    isBlank = "".isBlank()
    println(isBlank)

    val yourBasedness = "cringe"
    val myBasedness = "cringe (based)"

    val yourpH = 0f
    val mypH = 14.1f

    if ( (yourBasedness != myBasedness) && (yourpH != mypH) ) {
        println("both checked statements r true")
    }
    // || is or

    var beh1 = "jeff"
    var beh2 = "NOT jeff"

    println("${beh1 == beh2} ${beh1.equals(beh2)} ${beh1 === beh2}")

    beh2 = "jeff"

    println("${beh1 == beh2} ${beh1.equals(beh2)} ${beh1 === beh2}")
    // true true true
    // Quoting video, "a Kotlin """caveat""" ": numbers, chars and bools are all primitive types in Kotlin.

    var beh3 = Jeff("jeff")
    var beh4 = Jeff("NOT jeff")

    println("${beh3 == beh4} ${beh3.equals(beh4)} ${beh3 === beh4}")
    println("${beh3.name == beh4.name} ${beh3.name === beh4.name}")

    beh4 = Jeff("jeff")

    println("${beh3 == beh4} ${beh3.equals(beh4)} ${beh3 === beh4}")
    println("${beh3.name == beh4.name} ${beh3.name === beh4.name}")

    var weh1 = Jeff("jeff")
    var weh2 = Jeff("jeff")

    println("${weh1 == weh2} ${weh1 === weh2}")

    /*** null stuff ***/
    var name: String = "Jeff" // not nullable
    var name2: String? = "Jeffuel"
    name2 = null // And thus Jeffuel is no more.
    var aJeff: Jeff? = Jeff("not jeff")
    aJeff = null

    // Checking length of a nullable reference properly - safe call
    val length2 = name2?.length // if it's null, make it null, otherwise give it an integer length
    println(length2) // ...or:
    val length3 = if (name2 != null) name2.length else 0
    println(length3)
    val length4 = name2?.substring(0, 2)?.length
    var name3: String? = "jeffjeffjeffjeffjeffjeff"
    val length5 = name2?.substring(0,5)?.drop(2)?.substring(2,3)?.length
    print(length5)

    var lastName: String? = "Riamu"

    var lengthA: Int = if (lastName != null) lastName.length else 0

    var lengthB: Int = lastName?.length ?: 0

    SwingTest()
}

class Jeff(var name: String)